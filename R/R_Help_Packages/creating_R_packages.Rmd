---
title: "Instruction for creating a custom R package"
author: "Miroslav Kucera"
date: "`r Sys.Date()`"
output:
   html_document:
      css: custom_css.css
      toc: true
      toc_float:
         toc_collapsed: true
      number_sections: true
---


```{r global_options, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = " ")
```

```{r warning = FALSE, message = FALSE, results = 'hide', echo = FALSE}
# Load required libraries, set selected options

rm(list = ls())

lapply(c("knitr",
         "magrittr",
         "tidyverse",
         "devtools",
         "roxygen2"), library, character.only = TRUE)

# Define paths to directories that are to be used throughout this section

rootdir <- file.path("C:", "Users", "MK", "Documents", "pCloud_Sync_offline")
projdir <- file.path(rootdir, "Code_Examples", "R", "R_Help_Packages")
```


# Initialize a new package

Function *package.skeleton* from *utils* package creates a basic structure of the new
package. Note that the code is to be run only once, so `eval = FALSE` in the markdown file
afterwards.

```{r, eval = FALSE, results = 'hide'}
utils::package.skeleton(name = "testpckg", path = paste(projdir, sep = "/"))
```

The result is a new folder *testpckg* (acronym for "test package") inside
*Packages* folder; *testpckg* is populated with subfolders and files that together constitute
an R package. These can be modified, other files will be added, etc., to complete
the package.


# Clean up the skeleton package

First, delete the file *NAMESPACE* that was created automatically as a part of the
initial skeleton package generated above. The package *Roxygen2* we will be using to
compile our documentation will generate a new *NAMESPACE* automatically. Also remove
other files in folders *R*, *man*, and *data* (this one may not be needed at all).


# Add content to the package

As an example, we'll create an R script containing a simple function which will be
included into the package. We'll start by creating an empty R script file named
*keep_objects.R* in the *testpckg/R* subfolder. The name of the file is the same as
the name of the function it contains. In this case the purpose of the function is to
retain the specified objects in the current workspace and clear everything else. The
function's code is:
```{r, eval = FALSE}
keep_objects <- function(x) { 
    rm(list = setdiff(ls(globalenv()), x), envir = globalenv())
}
```


# Generate documentation

As mentioned above, the package *Roxygen2* we will be using to compile our documentation
will generate a new *NAMESPACE* file automatically. Now we need to put comments into 

Then add comments to the content (functions) of the package. Note that comments have
to be of specific type and format for *Roxygen* to be able to compile meaningful
documentation from them. To find out how to do that, read "Writing Documentation with
*Roxygen2*" at the https://kbroman.org/pkg_primer/pages/docs.html. Additional resources
can be found at https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html
or http://r-pkgs.had.co.nz/man.html.

In our example of the *keep_objects* function, the comments can be seen in the R script
file. Thus, the R script contains not only the function definition itself but also
tags that specify function's title, description, specify the parameters (arguments)
it takes, what it returns. We can also list examples of how to use the function. 

Once all the relevant files of code have been annotated with comments in Roxygen-like
style, the following code will compile them to create documentation for the package.
```{r, eval = TRUE}
devtools::document(file.path(projdir, "testpckg"))
```
Using the comments in the R script *keep_objects.R*, *Roxygen2* generates *keep_objects.Rd*
file in the subfolder *testpckg/man* that was until then empty. all *Rd* files (as in 
*R documentation*) have a latex-like syntax, and will generate all the help items
for the package and its functions.


# Build/rebuild the package

We can built and re-built the package whenever needed using functions from the *devtools*
package. Note that the path in the *build* function must lead to the directory in which
the package is stored. The build will produce a *tar.gz* (compressed) file; the file's
name and version are automatically generated by the *build* function using information
from the package's *DESCRIPTION* file).
```{r, eval = TRUE}
devtools::build(file.path(projdir, "testpckg"))
```

Every time we make changes to the package (and/or want to release a new version), the
package needs to be rebuilt. Also, the version number in the *DESCRIPTION* should be
changed which will also be reflected in a new *tar.gz* file and file name.


# Installation and loading

The package can be installed from the *.tar.gz* file.
```{r, eval = TRUE}
install.packages(file.path(projdir, "testpckg_1.0.tar.gz"), type = "source", repos = NULL)
```

Once installed, we can load it and work with it. For example, we can see what help and
description do we get with the package.
```{r, eval = TRUE}
library("testpckg")
packageDescription("testpckg")
help(package = "testpckg") # Displayed in the 'Help' tab in RStudio
library(help = "testpckg") # Displayed in RStudio's console
```

We can also get help for a specific function using the question mark. Note that it's
a good practice to prefix the function name with the name of the package followed by
two colon symbols. This is because sometimes the same function name can be used in more
than one package, and adding the name of the package avoids dubiousness.
```{r, eval = FALSE}
?testpckg::keep_objects # Displayed in the 'Help' tab in RStudio
```


Of course, the package can be "unloaded" from the current R session:
```{r, eval = TRUE}
detach(package:testpckg, unload = TRUE)
```
and it can also be uninstalled if need be:
```{r, eval = TRUE}
remove.packages("testpckg")
```
